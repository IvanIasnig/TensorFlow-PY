Praticamente il discorso è che Python è lento ad operare coi vettori (ricordarsi che ogni cosa è un vettore di 0 e 1)
Numpy esegue un ottimizzazione della vettorizzazione chiamata Broadcasting che di fatto elimina il loop per fare i calcoli

---------------------INTRO---------------------------

1. `shape`: Una tupla che rappresenta la forma dell'array, ovvero il numero di elementi lungo ogni dimensione.
2. `ndim`: Il numero di dimensioni dell'array.
3. `dtype`: Un oggetto `dtype` che descrive il tipo di dati degli elementi dell'array.
4. `size`: Il numero totale di elementi nell'array.
5. `itemsize`: La dimensione (in byte) di ciascun elemento dell'array.
6. `strides`: Una tupla di interi che indica il numero di byte da saltare nella memoria per passare al successivo elemento lungo ogni dimensione dell'array.

----------------------CREATING ARRAYS--------------------------

1. `pippo`: Questo array viene creato utilizzando la funzione `np.ones()`, che genera un array di "uno" con la stessa forma di `sample_array` (in questo caso, con 3 elementi). Il tipo di dati dell'array è specificato come `int64`. Il risultato è un array con i valori `[1, 1, 1]`.
2. `pluto`: Questo array viene creato utilizzando la funzione `np.zeros()`, che genera un array di "zero" con la forma specificata `(4, 5)`. Il tipo di dati dell'array è specificato come `int64`. Il risultato è un array 4x5 con tutti i valori uguali a 0.
3. `range_array`: Questo array viene creato utilizzando la funzione `np.arange()`, che genera un array di valori equidistanti nell'intervallo specificato. In questo caso, l'intervallo va da 10 (incluso) a 23 (escluso), con un passo di 4. Il risultato è un array con i valori `[10, 14, 18, 22]`.
4. `random_array`: Questo array viene creato utilizzando la funzione `np.random.randint()`, che genera un array di numeri interi casuali nell'intervallo specificato. In questo caso, l'intervallo va da 0 (incluso) a 10 (escluso), e la forma dell'array è `(3, 5)`. Il risultato è un array 3x5 con numeri interi casuali tra 0 e 9.
5. `random_array2`: Questo array viene creato utilizzando la funzione `np.random.random()`, che genera un array di numeri casuali tra 0 (incluso) e 1 (escluso) con la forma specificata `(3, 5)`. Il risultato è un array 3x5 con valori decimali casuali tra 0 e 1.
6. `random_array3`: Questo array viene creato utilizzando la funzione `np.random.rand()`, che genera un array di numeri casuali tra 0 (incluso) e 1 (escluso) con la forma specificata `(5, 3)`. A differenza di `np.random.random()`, questa funzione accetta direttamente le dimensioni dell'array come argomenti separati invece di una tupla. Il risultato è un array 5x3 con valori decimali casuali tra 0 e 1.

----------------------RANDOM SEED--------------------------

Viene impostato un seed fisso per garantire che l'output sia riproducibile e consistente ad ogni esecuzione. L'array generato ha 3 righe e 5 colonne, con numeri interi casuali compresi tra 0 e 9 (incluso 0, escluso 10).
Secrets utilizza un generatore di numeri casuali crittograficamente sicuro (CSPRNG)

---------------------VIEWING ARRAYS AND MATRICES------------------

1. `x = np.unique(random_array_4)`: La funzione `numpy.unique()` restituisce un array ordinato degli elementi unici dell'input fornito. In questo caso, l'array `random_array_4` viene passato alla funzione e gli elementi unici vengono assegnati alla variabile `x`.

2. `print(random_array_4[0])`: Stampa il primo elemento (indice 0) dell'array `random_array_4`. A seconda delle dimensioni di `random_array_4`, questo potrebbe essere un numero singolo o un sotto-array.

3. `print(random_array_4[1:])`: Stampa tutti gli elementi dell'array `random_array_4` a partire dall'elemento con indice 1 (il secondo elemento) fino alla fine dell'array.

4. `print(random_array_4[:2])`: Stampa gli elementi dell'array `random_array_4` dall'inizio fino all'elemento con indice 2 escluso (cioè, il terzo elemento).

5. `random_array_5 = np.random.randint(10, size=(2,3,4,5))`: Crea un array a 4 dimensioni di numeri interi casuali tra 0 e 9 inclusi, con la forma (2, 3, 4, 5) e assegna l'array risultante alla variabile `random_array_5`.
    l'array random_array_5 è composto da: 
    -2 matrici, ciascuna delle quali è composta da:
    -3 matrici, ciascuna delle quali è composta da:
    -4 righe, ciascuna delle quali è composta da:
    -5 elementi, ciascuno dei quali è un numero intero casuale tra 0 e 9 inclusi.
    
6. `print(random_array_5[:,:,:,:3])`: Stampa un sotto-array di `random_array_5` che include tutti gli elementi delle prime tre dimensioni e i primi tre elementi (dall'indice 0 all'indice 2 incluso) della quarta dimensione. Questo sotto-array avrà la forma (2, 3, 4, 3).

----------------------MANIPULATING ARRAYS---------------------------

1. `x = a1 + ones`: Aggiunge elemento per elemento gli array `a1` e `ones`. Poiché `ones` è un array di 1, aggiunge 1 a ogni elemento di `a1`. Output: `[2. 3. 4.]`.

2. `x2 = a1 - ones`: Sottrae elemento per elemento gli array `a1` e `ones`. Poiché `ones` è un array di 1, sottrae 1 da ogni elemento di `a1`. Output: `[0. 1. 2.]`.

3. `x3 = a1 * a2`: Moltiplica elemento per elemento gli array `a1` e `a2`. Output: `[[ 1.   4.   9.9] [ 4.  10.  19.5]]`.

4. `x3a = a2 / a1`: Esegue la divisione elemento per elemento tra gli array `a2` e `a1`. Output: `[[1.  1.  1.1] [4.  2.5 2.16666667]]`.

5. `x3b = a2 // a1`: Esegue la divisione intera elemento per elemento tra gli array `a2` e `a1`. Output: `[[1. 1. 1.] [4. 2. 2.]]`.

6. `x3c = a2 ** a1`: Eleva ogni elemento di `a2` alla potenza dell'elemento corrispondente in `a1`. Output: `[[  1.     4.    35.937] [ 64.   625.  753.571]]`.

7. `x3d = np.sqrt(a2)`: Calcola la radice quadrata di ogni elemento in `a2`. Output: `[[1.         1.41421356 1.81659021] [2.         2.23606798 2.54950976]]`.

8. `x3e = a2 % a1`: Calcola il modulo (resto della divisione) elemento per elemento tra gli array `a2` e `a1`. Output: `[[0. 0. 0.3] [0. 1. 0.5]]`.

9. `x3f = np.add(a2, 8)`: Aggiunge 8 a ogni elemento in `a2`. Output: `[[ 9.  10.  11.3] [12.  13.  14.5]]`.

10. `x3g = a2 % 2`: Calcola il modulo rispetto a 2 per ogni elemento in `a2`. Output: `[[1. 0. 1.3] [0. 1. 0.5]]`.

11. `x3h = np.exp(a1)`: Calcola l'esponenziale (e^x) di ogni elemento in `a1`. Output: `[ 2.71828183  7.3890561  20.08553692]`.

12. `x3i = np.log(a1)`: Calcola il logaritmo naturale di ogni elemento in `a1`. Output: `[0.         0.69314718 1.09861229]`.

Per quanto riguarda l'operazione `a2 * a3`, non è possibile effettuarla direttamente come moltiplicazione elemento per elemento perché gli array hanno forme incompatibili:

- `a2` ha forma `(2, 3)`: un array 2D con 2 righe e 3 colonne.
- `a3` ha forma `(2, 3, 3)`: un array 3D con 2 matrici, ciascuna con 3 righe e 3 colonne.

La moltiplicazione elemento per elemento richiede che gli array abbiano la stessa forma, e in questo caso, le forme di `a2` e `a3` non corrispondono. Pertanto, non è possibile eseguire direttamente l'operazione `a2 * a3`.

Tuttavia, potresti esaminare altre operazioni tra array, come il prodotto scalare, il prodotto esterno o il broadcasting, a seconda del contesto e delle tue esigenze specifiche.